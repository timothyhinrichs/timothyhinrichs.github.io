<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Rule Your Cloud</title>
        <description>Using declarative rules to manage the cloud</description>
        <link>http://timothyhinrichs.github.io</link>
        <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
                <title>Congress Overview</title>
                <description>&lt;p&gt;In the first few parts of this series, we discussed the &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=http-3A__networkheresy.com_2014_04_22_on-2Dpolicy-2Din-2Dthe-2Ddata-2Dcenter-2Dthe-2Dpolicy-2Dproblem_&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=ikyB-WX57pAJkbW5gNV_BF7k30OeiMe0wuPMjQRxbvs&amp;amp;e=&quot;&gt;policy problem&lt;/a&gt;, we outlined dimensions of the &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=http-3A__networkheresy.com_2014_06_19_on-2Dpolicy-2Din-2Dthe-2Ddata-2Dcenter-2Dthe-2Dsolution-2Dspace_&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=EMCGKhtAEyb5bzZX0uPGuCLH_CdcaC_Xx0Wi8tv8gto&amp;amp;e=&quot;&gt;solution space&lt;/a&gt;, and we gave a brief overview of the existing &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=http-3A__networkheresy.com_2014_09_17_on-2Dpolicy-2Din-2Dthe-2Ddata-2Dcenter-2Dcomparing-2Dopenstack-2Dpolicy-2Defforts_&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=w8YW4LfLEzz-cREcijAO3STdxnJr9m1Zl0tgtvEsnVE&amp;amp;e=&quot;&gt;OpenStack policy efforts&lt;/a&gt;. In this post we do a deep dive into one of the (not yet incubated) OpenStack policy efforts: Congress.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Remember that to solve the policy problem, people take ideas in their head about how the data center ought to behave (“policy”) and codify them in a language the computer system can understand. That is, the policy problem is really a programming languages problem. Not surprisingly Congress is, at its core, a policy language plus an implementation of that language.&lt;/p&gt;

&lt;p&gt;Congress is a standard cloud service; you install it on a server, give it some inputs, and interact with it via a RESTful API. Congress has two kinds of inputs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The other cloud services you’d like it to manage (for example, a compute manager like OpenStack Nova and a network manager like OpenStack Neutron)&lt;/li&gt;
  &lt;li&gt;A policy that describes how those services ought to behave&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, we might decide to use Congress to manage OpenStack’s Nova (compute), Neutron (networking), Swift (object storage), Cinder (block storage), and Heat (applications). We might write a geo-location policy:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Every application collecting personal information about its users from Japan must have all of its compute, networking, and storage elements deployed at a data center that resides within the geographic borders of Japan.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;any-service&quot;&gt;Any Service&lt;/h2&gt;

&lt;p&gt;A cloud service gives Congress the ability to see and change the data center’s behavior. The more services hooked up to Congress, the more powerful Congress becomes. Congress was designed to manage &lt;strong&gt;any&lt;/strong&gt; collection of cloud services, regardless of their origin or locality (private or public). It does not matter if the service is provided by OpenStack, CloudStack, AWS, GCE, Cisco, HP, IBM, Red Hat, VMware, etc. It does not matter if the service manages compute, networking, storage, applications, databases, anti-virus, inventory, people, or groups. Congress is vendor and domain agnostic.&lt;/p&gt;

&lt;p&gt;Congress provides a unified abstraction for all services, which insulates the policy writer from understanding differing data formats, authentication protocols, APIs, and the like. Congress does NOT require any special code to be running on the services it manages; rather, it includes a light-weight adapter for each service that implements the unified interface using the service’s native API.&lt;/p&gt;

&lt;p&gt;From the policy writer’s point of view, each service is simply a collection of tables. A &lt;em&gt;table&lt;/em&gt; is a collection of rows; each &lt;em&gt;row&lt;/em&gt; is a collection of columns; each row-column entry stores simple data like strings and integers. When Congress wants to see what is happening in the data center, it reads from those tables. When Congress wants to change what is happening in the data center, it writes to those tables.&lt;/p&gt;

&lt;p&gt;For example, the Nova compute service is represented as several tables like the &lt;em&gt;servers&lt;/em&gt; table below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+----------+--------+-----------+----------+-----------+
| id      | host_id  | status | tenant_id | image_id | flavor_id |
+---------+----------+--------+-----------+----------+-----------+
| &amp;lt;UUID1&amp;gt; | &amp;lt;UUID2&amp;gt;  | ACTIVE | alice     | &amp;lt;UUID3&amp;gt;  | &amp;lt;UUID4&amp;gt;   |
| &amp;lt;UUID5&amp;gt; | &amp;lt;UUID6&amp;gt;  | ACTIVE | bob       | &amp;lt;UUID7&amp;gt;  | &amp;lt;UUID8&amp;gt;   |
| &amp;lt;UUID9&amp;gt; | &amp;lt;UUID10&amp;gt; | DOWN   | bo        | &amp;lt;UUID7&amp;gt;  | &amp;lt;UUID8&amp;gt;   |
+---------+----------+--------+-----------+----------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the time of writing, there are adapters (which we call “datasource drivers”) for each of the following services, all but one of which are OpenStack.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nova&lt;/li&gt;
  &lt;li&gt;Neutron&lt;/li&gt;
  &lt;li&gt;Cinder&lt;/li&gt;
  &lt;li&gt;Swift&lt;/li&gt;
  &lt;li&gt;Keystone&lt;/li&gt;
  &lt;li&gt;Ceilometer&lt;/li&gt;
  &lt;li&gt;Glance&lt;/li&gt;
  &lt;li&gt;Plexxi controller&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each adapter is a few hundred lines of code that (i) makes API calls into the service to get information about that service’s behavior; and (ii) translates that information into tables. Just recently we added a domain-specific language (DSL) that automates the translation of that information into tables, given a description of the structure of the information.&lt;/p&gt;

&lt;p&gt;For more information about connecting cloud services, see the &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_stackforge_congress_blob_master_doc_source_cloudservices.rst&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=FPaq8W-EjeCmNEgAykSya9oXPGVpmFfwd7-BUSNGGOY&amp;amp;e=&quot;&gt;Congress cloud services documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;any-policy&quot;&gt;Any Policy&lt;/h2&gt;

&lt;p&gt;A policy describes how a collection of cloud services ought to behave. Every organization’s policy is unique because every organization has different services in its data center. Every organization has different business advantages they are trying to gain via the cloud. Every organization has different regulations that govern it. Every organization is full of people with different ideas about the right way to run the cloud.&lt;/p&gt;

&lt;p&gt;Congress aims to provide a single policy language that every organization can use to express their high- and low-level policies. Instead of providing a long list of micro-policies that the user can mix-and-match, Congress provides a general purpose policy language for expressing policy: the well-known declarative language &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=https-3A__en.wikipedia.org_wiki_Datalog&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=AxahykhT2a2MqS4Rs0r4CBehfoQVYgWRNIePmV-E4kY&amp;amp;e=&quot;&gt;Datalog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Datalog is domain-agnostic.&lt;/strong&gt;  It is just as easy to write policy about compute as it is to write policy about networking. It is just as easy to write policy about how compute, networking, storage, group membership, and applications interact with each other. Moreover, Datalog enables policy writers to define abstractions to bridge the gap between low-level infrastructure policy and high-level business policy.&lt;/p&gt;

&lt;p&gt;Suppose our policy says that all servers should on average have a CPU utilization of at least 20% over a 2 day span. In Datalog we would write the a policy that leverages Nova for compute, Ceilometer for CPU utilization data, and some built-in tables that treat strings as if they were dates.&lt;/p&gt;

&lt;p&gt;First, we declare the conditions under which there is a policy violation. We do that by writing a rule that says a VM is an error (policy violation) if the conditions shown below are true.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error(vm, email_address) :-
	nova:servers(id=myid, tenant_id=owner), // myid is a server owned by owner
	two_days_previous(start_date, end_date), // start_date is 2 days before end_date; end_date is today
	ceilometer:statistics(id=myid, start=start_date, end=end_date, meter=&quot;cpu-util&quot;, avg=value),
	arithmetic:less_than(value, 20), // value &amp;lt; 20%
	keystone:user(id=owner, email=email_address)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also define a helper table that computes the start and end dates for 2 days before today.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;two_days_previous(start_date, end_date) :-
	datetime:now(end_date),
	datetime:minus(end_date, &quot;2 days&quot;, start_date)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helper tables like &lt;code&gt;two_days_previous&lt;/code&gt; are useful because they allow the policy writer to create higher-level concepts that may not exist natively in the cloud services. For example, we can create a helper table that tells us which servers are connected to the Internet—something that requires information from several different places in OpenStack. Or the compute, networking, and storage admins could create the higher-level concept “is-secure” and enable a higher-level manager to write a policy that describes when resources ought to be secured.&lt;/p&gt;

&lt;p&gt;For more information about writing policy, see the &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_stackforge_congress_blob_master_doc_source_policy.rst&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=krf12kU7aAFCJsQw5MWsEQelvyKgqjcMlINQMIu7qNI&amp;amp;e=&quot;&gt;Congress policy documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;capabilities&quot;&gt;Capabilities&lt;/h2&gt;

&lt;p&gt;Once we have connected services to Congress and written policy over those services, we’ve given Congress the inputs it needs carry out its core capabilities, which the user is free to mix and match.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Monitoring:&lt;/strong&gt; Congress watches how the other cloud services are behaving, compares that to policy, and flags mismatches (policy violations).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Enforcement:&lt;/strong&gt; Congress acts as a policy authority. A service can propose a change to Congress, and Congress will tell the service whether the change complies with policy or not, thus preventing policy violations before they happen. Congress can also correct some violations after the fact.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Auditing:&lt;/strong&gt; Congress gives users the ability to record the history of policy, policy violations, and remediations.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Delegation:&lt;/strong&gt;  Congress can offload the burden of monitoring/enforcing/auditing to other policy-aware systems.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When it comes to enforcement, a common question is why Congress would support both proactive and reactive enforcement. The implied question being, “Isn’t proactive always preferred?”  The answer is that proactive is not always possible. Consider the simple policy “ensure all operating systems have the latest security patch.”  As soon as Microsoft/Apple/RedHat releases a new security patch, the policy is immediately violated; the whole purpose of writing the policy is to enable Congress to identify the violation and take action to correct it.&lt;/p&gt;

&lt;p&gt;The tip of &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_stackforge_congress&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=sGkISF1PUrr3cWS-Pko-rcU9Wl0VEoLP_e1Haw9zKbY&amp;amp;e=&quot;&gt;master&lt;/a&gt; includes monitoring and a mechanism for proactive enforcement. In the Kilo release of OpenStack we plan to have a form of reactive enforcement available as well.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this post, we’ve talked about some of the key takeaways regarding Congress:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Congress was designed to solve the policy problem and work with any cloud service and any policy.&lt;/li&gt;
  &lt;li&gt;It is currently capable of monitoring and proactive enforcement. Reactive enforcement and delegation are currently underway.&lt;/li&gt;
  &lt;li&gt;Congress is not yet incubated in OpenStack, but has contributions from half a dozen organizations and nearly two dozen people.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please feel free to join our weekly &lt;a href=&quot;https://wiki.openstack.org/wiki/Meetings/Congress&quot;&gt;IRC meeting&lt;/a&gt;, check out the &lt;a href=&quot;https://wiki.openstack.org/wiki/Congress&quot;&gt;wiki&lt;/a&gt;, and download and install the &lt;a href=&quot;https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_stackforge_congress_blob_master_README.rst&amp;amp;d=AAIFAQ&amp;amp;c=Sqcl0Ez6M0X8aeM67LKIiDJAXVeAw-YihVMNtXt-uEs&amp;amp;r=B6BWd4kFfgOzAREgThxkmTZKy7dDXE2-eBAmL0PBK7s&amp;amp;m=hVvRmTqHcVw4UXsbw4bLSzFzqFk1CHpESe6J7d-DpyU&amp;amp;s=3mKMRBmi1mP4HflP5LeWz2qnZKGYgm-c_eK_CF6GmKs&amp;amp;e=&quot;&gt;code&lt;/a&gt;.&lt;/p&gt;

</description>
                <pubDate>Mon, 01 Dec 2014 00:00:00 -0800</pubDate>
                <link>/2014/12/01/congress-overview.html</link>
                <guid isPermaLink="true">/2014/12/01/congress-overview.html</guid>
            </item>
        
            <item>
                <title>Openstack Policy Efforts</title>
                <description>&lt;p&gt;In the first two parts of this blog series we discussed the problem of &lt;a href=&quot;http://networkheresy.com/2014/04/22/on-policy-in-the-data-center-the-policy-problem/&quot;&gt;policy in the data center&lt;/a&gt; and &lt;a href=&quot;http://networkheresy.com/2014/06/19/on-policy-in-the-data-center-the-solution-space/&quot;&gt;the features that differentiate solutions to that problem&lt;/a&gt;. In this post, we give a high-level overview of several policy efforts within OpenStack.&lt;/p&gt;

&lt;p&gt;Remember that a &lt;em&gt;policy&lt;/em&gt; is a description of how (some part of) the data center ought to behave, a &lt;em&gt;service&lt;/em&gt; is any component in the data center that has an API, and a &lt;em&gt;policy system&lt;/em&gt; is designed to manage some combination of past, present, and future policy violations (auditing, monitoring, and enforcement, respectively).&lt;/p&gt;

&lt;p&gt;The overview of OpenStack policy efforts talks about the features we identified in part 2 of this blog series. To recap, those features are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Policy language: how expressive is the language, is the language restricted to certain domains, what features (e.g. exceptions) does it support?&lt;/li&gt;
  &lt;li&gt;Policy sources: what are the sources of policy, how do different sources of policy interact, how are conflicts dealt with?&lt;/li&gt;
  &lt;li&gt;Services: which other data center services can be leveraged and how?&lt;/li&gt;
  &lt;li&gt;Actions: what does the system do once it is given a policy: monitor (identify violations), enforce (prevent or correct violations), audit (analyze past violations)?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one thing you’ll notice is that there are many different policy efforts within OpenStack. Perhaps surprisingly there is actually little redundancy because each effort addresses a different part of the overall policy problem: enabling users to describe their desires in a way that an OpenStack cloud can act on them. Additionally, as we will point out again later in the post, domain independent and domain specific policy efforts are highly complementary.&lt;/p&gt;

&lt;h2 id=&quot;congress&quot;&gt;Congress&lt;/h2&gt;

&lt;p&gt;We begin with &lt;a href=&quot;https://wiki.openstack.org/wiki/Congress&quot;&gt;Congress&lt;/a&gt;, our own policy effort within OpenStack. Congress is a system purpose-built for managing policy in the data center. A Congress policy describes the desired behavior of the data center by dictating how all the services running in that data center are supposed to behave both individually and in tandem. In the current release Congress accepts a single policy for the entire data center, the idea being that the cloud administrators are jointly responsible for writing and maintaining that policy.&lt;/p&gt;

&lt;p&gt;A Congress policy is domain independent and can describe the behavior of any collection of data center services. The cloud administrator can write a policy about networking, a policy about compute, or a policy that about networking, compute, storage, antivirus, organizational charts, inventory management systems, ActiveDirectory, and so on.&lt;/p&gt;

&lt;p&gt;The recent &lt;a href=&quot;https://github.com/stackforge/congress&quot;&gt;alpha release of Congress&lt;/a&gt; supports monitoring violations in policy: comparing how the data center is actually behaving to how policy says the data center ought to behave and flagging mismatches. In the future, Congress will also support enforcement by having Congress itself execute API calls to change the behavior of the data center and/or pushing policy to other policy-aware services better positioned to enforce policy.&lt;/p&gt;

&lt;h2 id=&quot;neutron-group-based-policy-gbp-4&quot;&gt;&lt;a href=&quot;https://docs.google.com/document/d/1ZbOFxAoibZbJmDWx1oOrOsDcov6Cuom5aaBIrupCD9E/edit?pli=1&quot;&gt;Neutron Group-Based Policy (GBP)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;GBP, which is similar to the policy effort in &lt;a href=&quot;https://wiki.opendaylight.org/view/Group_Policy:Main&quot;&gt;OpenDaylight&lt;/a&gt;, utilizes policy to manage networking. A policy describes how the network packets in the data center are supposed to behave. Each policy (“contract” in GBP terminology) describes which actions (such as allow, drop, reroute, or apply QoS) should be applied to which network packets based on packet header properties like port and protocol. Entities on the network (called “endpoints”) are grouped and each group is assigned one or more policies. Groups are maintained outside the policy language by people or automated systems.&lt;/p&gt;

&lt;p&gt;In GBP, policies can come from any number of people or agents. Conflicts can arise within a single policy or across several policies and are eliminated by a mechanism built into GBP (which is out of scope for this blog post).&lt;/p&gt;

&lt;p&gt;The goal of GBP is to enforce policy directly. (Both monitoring and auditing are challenging in the networking domain because there are so many packets moving so quickly throughout the data center.) To do enforcement, GBP compiles policies down into existing Neutron primitives and creates logical networks, switches, and routers. When new policy statements are inserted, GBP does an incremental compilation: changing the Neutron primitives in such a way as to implement the new policy while minimally disrupting existing primitives.&lt;/p&gt;

&lt;h2 id=&quot;swift-storage-policy&quot;&gt;Swift Storage Policy&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.openstack.org/wiki/Swift&quot;&gt;Swift&lt;/a&gt; is OpenStack’s object storage service. As of version 2.0, released &lt;a href=&quot;https://www.openstack.org/blog/2014/07/openstack-swift-2-0-released-and-storage-policies-have-arrived/&quot;&gt;July 2014&lt;/a&gt;, Swift supports &lt;a href=&quot;http://docs.openstack.org/developer/swift/overview_policies.html&quot;&gt;storage policies&lt;/a&gt;. Each storage policy is attached to a virtual storage system, which is where Swift stores objects. Each policy assigns values to a number of built-in features of a storage system. At the time of writing, each policy dictates how many partitions the storage system has, how many replicas of each object it should maintain, and the minimum amount of time before a partition can be moved to a different physical location since the last time it was moved.&lt;/p&gt;

&lt;p&gt;A user can create any number of virtual storage systems—and so can write any number of policies—but there are no conflicts between policies. If we put an object into a container with 2 replicas and the same object into another container with 3 replicas, it just means we are storing that object in two different virtual storage systems, which all told means we have 5 replicas.&lt;/p&gt;

&lt;p&gt;Policy is enforced directly by Swift. Every time an object is written, Swift ensures the right number of replicas are created. Swift ensures not to move a partition before policy allows that partition to be moved.&lt;/p&gt;

&lt;h2 id=&quot;smart-schedulersolverscheduler&quot;&gt;Smart Scheduler/SolverScheduler&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://blueprints.launchpad.net/nova/+spec/solver-scheduler&quot;&gt;Smart Scheduler/SolverScheduler&lt;/a&gt; effort aims to provides an interface for using different constraint solvers to solve optimization problems for other projects, &lt;a href=&quot;https://blueprints.launchpad.net/nova/+spec/solver-scheduler&quot;&gt;Nova&lt;/a&gt; in particular. One specific use case is for Network Functions Virtualization (see &lt;a href=&quot;http://openstacksummitmay2014atlanta.sched.org/event/44d44e392250173c4a0344bf27c58860#.U9aFP1hg7zY&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://docs.google.com/a/vmware.com/document/d/1k60BQXOMkZS0SIxpFOppGgYp416uXcJVkAFep3Oeju8/edit#&quot;&gt;here&lt;/a&gt;) For example, Nova might ask where to place a new virtual machine to minimize the average number of VMs on each server. This effort utilizes domain-independent solvers (such as linear programming/arithmetic solvers) but applies them to solve domain-specific problems. The intention is to focus on enforcement.&lt;/p&gt;

&lt;h2 id=&quot;nova-policy-based-scheduling-module&quot;&gt;Nova Policy-Based Scheduling Module&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://blueprints.launchpad.net/nova/+spec/policy-based-scheduler&quot;&gt;Nova policy-based scheduling module&lt;/a&gt; aims to schedule Nova resources per client, per cluster of resources, and per context (e.g. overload, time, etc.). A &lt;a href=&quot;http://openstacksummitmay2014atlanta.sched.org/event/b4313b37de4645079e3d5506b1d725df#.U9aNq1hg7zY&quot;&gt;proof of concept was presented&lt;/a&gt; at the Demo Theater at OpenStack Juno Summit.&lt;/p&gt;

&lt;h2 id=&quot;gantt&quot;&gt;Gantt&lt;/h2&gt;

&lt;p&gt;Gantt aims to provide scheduling as a service for other OpenStack components (see &lt;a href=&quot;https://wiki.openstack.org/wiki/Gantt&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://github.com/openstack/gantt&quot;&gt;here&lt;/a&gt;). Previously, it was a subgroup of Nova and focused on scheduling virtual machines based on resource utilization. It includes plugin framework for making arbitrary metrics available to the scheduler.&lt;/p&gt;

&lt;h2 id=&quot;heat-convergence-engine&quot;&gt;Heat Convergence engine&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://review.openstack.org/#/c/95907/7/specs/convergence.rst&quot;&gt;Heat Convergence engine&lt;/a&gt; represents a shift toward a model for Heat where applications are deployed and managed by comparing the current state of the application to the desired state of the application and taking action to reduce the differences. Each desired state amounts to a policy describing a single application. Those policies do not interact, logically, and can draw upon any service in the data center. Heat policies are concerned mainly with corrective enforcement, though monitoring is also useful (“how far along is my application’s deployment?”).&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The key takeaway is that OpenStack has a growing ecosystem of policy-aware services. Most of them are domain-specific, meaning they are systems tailored to enforcing a particular kind of policy for a particular service, but a few are domain-independent, meaning that they will work for any kind of policy.&lt;/p&gt;

&lt;p&gt;The strength of a domain-specific policy system is &lt;em&gt;enforcing&lt;/em&gt; policies within its domain, but its weakness is that policies outside the domain are not expressible in the language. The strength of a domain-independent policy system is &lt;em&gt;expressing&lt;/em&gt; policies for any and every domain, but its weakness is that monitoring/enforcing/auditing those policies can be challenging.&lt;/p&gt;

&lt;p&gt;For policy to live up to its expectations, we need a rich ecosystem of policy-aware services that interoperate with one another. Networking policies should be handled by Neutron; compute policies should be handled by Nova; storage policies should be handled by Swift and Cinder; application policies should be handled by Heat; cross-cutting policies should be handled by a combination of Congress, Gantt, and SolverScheduler. We believe it will be incredibly valuable to give users a single touch point to understand how all the policies throughout the data center interact and interoperate—to provide a dashboard where users ask questions about the current state of the data center, investigate the impact of proposed changes, enact and automate enforcement decisions, and audit the data center’s policy from the past.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;To help coordinate the interaction and development of policy-aware services and policy-related efforts in OpenStack, the &lt;a href=&quot;https://www.eventbrite.com/e/openstack-policy-summit-tickets-12642081807&quot;&gt;OpenStack Mid-Cycle Policy Summit&lt;/a&gt; intends to bring representatives from many different policy-minded companies and projects together. The aim of the summit is to discuss the current state of policy within OpenStack and begin discussing the roadmap for how policy will evolve in the future. The summit will start with some presentations by (and about) the various policy-related efforts and their approach to policy; it will wrap up with a workshop focused on how the different efforts might interoperate both today and in the future. Following this summit, which takes place September 18-19, 2014, we’ll post another blog entry describing the experience and lessons learned.&lt;/p&gt;

</description>
                <pubDate>Wed, 17 Sep 2014 00:00:00 -0700</pubDate>
                <link>/2014/09/17/openstack-policy-efforts.html</link>
                <guid isPermaLink="true">/2014/09/17/openstack-policy-efforts.html</guid>
            </item>
        
            <item>
                <title>Solution Space</title>
                <description>&lt;p&gt;In the &lt;a href=&quot;http://networkheresy.com/2014/04/22/on-policy-in-the-data-center-the-policy-problem/&quot;&gt;first part of this series&lt;/a&gt; we described the policy problem: ensuring that the data center obeys the real-world rules and regulations that are pertinent to that data center. In this post, we look at the range of possible solutions by identifying some the key features that are important for any solution to the policy problem.  Those key features correspond to the following four questions, which we use to structure our discussion.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What are the policy sources a policy system must accommodate?&lt;/li&gt;
  &lt;li&gt;How do those sources express the desired policy to the system?&lt;/li&gt;
  &lt;li&gt;How does the policy system interact with data center services?&lt;/li&gt;
  &lt;li&gt;What can the policy system do once it has the policy?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s take a look at each of these questions one at a time.&lt;/p&gt;

&lt;h2 id=&quot;policy-sources-the-origins-of-policy&quot;&gt;Policy Sources: The origins of policy&lt;/h2&gt;

&lt;p&gt;Let’s start by digging deeper into an idea we touched on in the first post when describing the challenge of policy compliance: the sources of policy. While we sometimes talk about there being a single policy for a data center, the reality is that there are really many different policies that govern a data center. Each of these policies may have a different source or origin. Here are some examples of different policy sources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Application developers may write a separate policy for each application describing what that application expects from the infrastructure (such as high availability, elasticity/auto-scaling, connectivity, or a specific deployment location).&lt;/li&gt;
  &lt;li&gt;The cloud operator may have a policy that describes how applications relate to one another. This policy might specify that applications from different business units must be deployed on different production networks, for example.&lt;/li&gt;
  &lt;li&gt;Security and compliance teams might have policies that dictate specific firewall rules for web servers, encryption for PCI-compliant workloads, or OS patching guidelines.&lt;/li&gt;
  &lt;li&gt;Different policies may be focused on different functionality within the data center. There might be a deployment policy, a billing policy, a security policy, a backup policy, and a decommissioning policy.&lt;/li&gt;
  &lt;li&gt;Policies may be written at different levels of abstraction, e.g. applications versus virtual machines (VMs), networks versus routers, storage versus disks.&lt;/li&gt;
  &lt;li&gt;Different policies might exist for different policy operations (monitoring, enforcing, and auditing are three examples that we will discuss later in this post).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The idea of multiple sources of policy naturally leads us to the presence of multiple policies. This is an interesting idea, because these multiple policies can interact with each other in many different ways. A policy describing where an application is to be deployed might also implicitly describe where VMs are to be deployed. A cloud operator’s policy might require an application to be deployed on network A or B, and an application policy requiring high availability might mean it must be deployed on network B or C; taken together, this means the application can only be deployed on network B. An auditing policy that requires knowing provenance for data when applied to an application that supports a high transaction rate might require solid state storage to meet performance requirements.&lt;/p&gt;

&lt;p&gt;Taking this a step further, it may be unclear how these policies should interact. If the backup policy says to have 3 copies of data, and an auditing policy requires keeping track of where the data originated, do we need 3 copies of that provenance information? Conflicts are another example. If the application’s policy implies networks A or B, and the cloud operator’s policy implies networks C or D, then there is no way to deploy that application so that both policies are satisfied simultaneously.&lt;/p&gt;

&lt;p&gt;There are a couple key takeaways from this discussion. First, a policy system must deal with multiple policy sources. Second, a policy system must deal with the presence of multiple policies, and how those policies can or should interact with one another.&lt;/p&gt;

&lt;h2 id=&quot;expressing-policy-policy-languages&quot;&gt;Expressing Policy: Policy languages&lt;/h2&gt;

&lt;p&gt;Any discussion of policy systems has to deal with the subject of policy languages. An intuitive, easy-to-use syntax is critically important for eventual adoption, but here we focus on more semantic issues: how domain-specific is the language? How expressive is the language? What general-purpose policy features belong to the language?&lt;/p&gt;

&lt;p&gt;A language is a domain specific language (DSL) if it includes primitives useful for policy in one domain but not another. For example, a policy language for networking might include primitives for the source and destination IP addresses of a network packet. A DSL for compute might include primitives for the amount of memory or disk space on a server. An application-oriented DSL might include elasticity primitives so that how different parts of the application grow and shrink can be the subject of policy.&lt;/p&gt;

&lt;p&gt;Different parts of a policy language can be domain-specific:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Namespace:&lt;/em&gt; The objects over which we declare policy can be domain-specific. For example, a networking DSL might define policy about packets, ports, switches, and routers.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Condition:&lt;/em&gt; Policy languages typically have if-then constructs, and the “if” part of those constructs can include domain-specific tests, such as the source and destination IP addresses on a network packet.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Consequent:&lt;/em&gt; The “then” component of if-then constructs can also be domain-specific.  For networking, this might include allowing/dropping a packet, sending a packet through a firewall and then a load balancer, or ensuring quality of service (QoS).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Independent of domain-specific constructs, a language has a fundamental limitation on its expressiveness (its “raw expressiveness”). Language A is more expressive than language B if every policy for B can be translated into a policy for A but not vice versa. For example, if language A supports the logical connectives AND/OR/NOT, and language B is the same except it only supports AND/OR, then A is more expressive than B. However, it can be the case that language A supports AND/OR/NOT, language B supports AND/NOT, and yet the two languages are equally expressive (because OR can be simulated with AND/NOT).&lt;/p&gt;

&lt;p&gt;It may seem that more expressiveness is necessarily better because a more expressive language makes it easier for users to write policies. Unfortunately, the more expressive a language, the harder it is to implement. By “harder to implement” we don’t mean it’s harder to get a 30% speed improvement through careful engineering; rather, we mean that it is provably impossible to make the implementation of sufficiently expressive languages run in less than exponential time. In short, every policy language chooses how to balance the policy writers’ need for expressiveness and the policy system’s need for implementability.&lt;/p&gt;

&lt;p&gt;On top of domain-specificity and raw expressiveness, different policy languages support different features. For example, can we say that some policy statements are “hard” (can never be violated) while other statements are “soft” (can be violated if the only way to not violate is to violate a hard constraint). More generally, can we assign priorities to policy statements? Is there native support for exceptions to policy rules (maybe a cloud owner wants to manually make an exception for a violation so that auditing reflects why that violation was less severe than it may have seemed). Does the language have policy modules and enable people to describe how to combine those modules to produce a new policy? While such features might not impact domain-specificity or raw expressiveness, they have a large impact on how easy the policy language—and therefore the system using that language—is to use.&lt;/p&gt;

&lt;p&gt;The key takeaway here is that the policy language has a significant impact on the policy system, so the choice of policy language is a critical one.&lt;/p&gt;

&lt;h2 id=&quot;policy-interaction-integrating-with-data-center-services&quot;&gt;Policy Interaction: Integrating with data center services&lt;/h2&gt;

&lt;p&gt;A policy system by itself is useless; to have value, the policy system must interact and integrate with other data center or cloud services. By “data center service” or “cloud service” we mean basically anything that has an API, e.g. OpenStack components like Neutron, routers, servers, processes, files, databases, antivirus, intrusion detection, inventory management.  Read-only API calls enable a policy system to &lt;em&gt;see&lt;/em&gt; what is happening; read/write API calls enable a policy system to &lt;em&gt;control&lt;/em&gt; what is happening.&lt;/p&gt;

&lt;p&gt;Since a policy system’s ability to do something useful with a policy (like prevent violations, correct violations, or monitor for violations) is directly related to what the service can see and do in the data center, it’s crucial to understand how well a policy system works with the services in a data center. If two policy systems are equivalent except that one works with a broader range of data center services than the other, the one with a broader selection of data center services has the ability to see and do more; thus, it’s better able to see and do things to help the data center obey policy.&lt;/p&gt;

&lt;p&gt;One type of data center service is especially noteworthy: the policy-aware service. Such services understand policy natively. They may have an API that includes “insert policy statement” and “delete policy statement”. Such services are especially useful in that they can potentially help the data center obey certain kinds of sub-policies. Distributing the work makes a policy system more robust, more reliable, and better performing.&lt;/p&gt;

&lt;p&gt;The key point to remember here is that a policy system’s “power” (knowledge of and control over what’s happening in a data center or cloud environment) is driven by the nature of its interaction with the services running in that data center.&lt;/p&gt;

&lt;h2 id=&quot;policy-action-taking-action-based-on-policy&quot;&gt;Policy Action: Taking action based on policy&lt;/h2&gt;

&lt;p&gt;Having looked at three key aspects of a policy system—supporting multiple sources of policies and multiple policies, using a policy language that balances expressiveness with implementability, and providing the appropriate depth and breadth of integration with necessary data center services—we now come to a discussion of what the policy system does (or can do) once it knows what policy (or group of policies) is pertinent to the data center. It’s compelling to think about the utility of policy in terms of the future, the present, and the past. We want the data center to obey the policy at all points in time, and there are different mechanisms for doing that.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Auditing: We cannot change the past but we can record how the data center behaved, what the policy was, and therefore what the violations were.&lt;/li&gt;
  &lt;li&gt;Monitoring: The present is equally impossible to change (by the time we act, that moment in time will have become the past), but we can identify violations, help people understand them, and gather information about how to reduce violations in the future.&lt;/li&gt;
  &lt;li&gt;Enforcement: We can change the future behavior of the data center by taking action. Enforcement can attempt to prevent violations before they occur (“proactive enforcement”) or correct violations after the fact (“reactive enforcement”). This is the most challenging of the three because it requires choosing and executing actions that affect the natural state of the data center.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The potential for any policy system to carry out these three functions depends crucially on two things: the policy itself (a function of how well the system supports multiple policies as well as the system’s choice of policy language) and the controls the policy system has over the data center (driven by the policy system’s interaction with and integration into the surrounding data center services). The combination of these two things impose hard limits on how well &lt;strong&gt;any&lt;/strong&gt; policy system is able to audit, monitor, and enforce policy.&lt;/p&gt;

&lt;p&gt;While we would rather prevent violations than correct them, it’s sometimes impossible to do so. For example, we cannot prevent violations in a policy that requires server operating system (OS) instances to always have the latest patches. Why? As soon as Microsoft, Apple, or Red Hat releases a new security patch, the policy is immediately violated. The point of this kind of policy is that the policy system recognizes the violation and applies the patch to the vulnerable systems (to correct the violation).  The key takeaway from this example is that &lt;em&gt;preventing violations requires the policy system is on the critical path for any action that might violate policy.&lt;/em&gt; Violations can only be prevented if such enforcement points are available.&lt;/p&gt;

&lt;p&gt;Similarly, it’s not always possible to correct violations. Consider a policy that says the load on a particular web server should never exceed 10,000 requests per second. If the requests to that server become high enough (even with load balancing), there may be no way reduce the load once it reaches 10,001 requests per second. The data center cannot control what web sites people in the real world access through their browsers. In this case, the key takeaway is that &lt;em&gt;correcting violations requires there be actions available to the policy system to counteract the causes of those violations.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Even policy monitoring has limitations. A policy dictating application deployment to particular data centers based on the users of that application assumes readily available information about where applications are deployed and the users of those applications. A web application that does not expose information about its users ensures even monitoring this policy is impossible. The key takeaway here is that &lt;em&gt;monitoring a policy requires that the appropriate information is available to the policy system.&lt;/em&gt; Further, if we cannot monitor a policy, we also cannot audit that policy.&lt;/p&gt;

&lt;p&gt;In short, every policy system has limitations. These limitations might be on what the policy system knows about the data center, or these limitations might be on what control it has over the data center. These limitations influence whether any given policy can be audited, monitored, and enforced. Moreover, these limitations can change as the data center changes. As new services (hardware or software) are installed or existing services are upgraded in the data center, new functionality becomes available, and a policy system may have additional power (fewer limitations). When old services are removed, the policy system may have less power (more limitations).&lt;/p&gt;

&lt;p&gt;These limitations give us ceilings on how successful any policy system might be in terms of auditing, monitoring, and enforcing policy. It is therefore useful to compare policy system &lt;strong&gt;designs&lt;/strong&gt; in terms of how close to those ceilings they can get. Of course, the true test is in terms of actual implementation, not design, and a comparison of systems in terms of what policies they can audit, monitor, and enforce at scale is incredibly valuable. However, we must be careful not to condemn systems for not solving unsolvable problems.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;This blog post has focused on laying out the range of possible solutions to the policy problem in the data center. In summary, here are some key points:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Policies come from many different sources and interact in many different ways. Ideally the data center would obey all those policies simultaneously, but in practice we expect the policies to conflict. A solution to the policy problem must address the issues surrounding multiple policies.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A policy language can be categorized in terms of its domain-specificity, its raw expressiveness, and the features it supports. Every solution must balance these three to meet the need for the policy writer to express policy and the need of the policy system to audit, monitor, and enforce policy.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Every solution must interact with the ecosystem of data center services within the data center. The richer the ecosystem a solution can leverage, the more successful it can be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a policy system has a policy, it can audit, monitor, and enforce that policy. A solution to the policy problem is more or less successful at these functions depending on the policy and the data center.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next blog post, we will look at proposed policy systems like the OpenStack Group-Based Policy and the Congress project, and explain how they fit into this solution space.&lt;/p&gt;

</description>
                <pubDate>Wed, 18 Jun 2014 00:00:00 -0700</pubDate>
                <link>/2014/06/18/solution-space.html</link>
                <guid isPermaLink="true">/2014/06/18/solution-space.html</guid>
            </item>
        
            <item>
                <title>Policy Problem</title>
                <description>&lt;p&gt;Fully automated IT provisioning and management is considered by many to be the ultimate nirvana—people log into a self-service portal, ask for resources (compute, networking, storage, and others), and within minutes those resources are up and running. No longer are the people who use resources waiting on the people who are responsible for allocating and maintaining them. And, according to the accepted definitions of cloud computing (for example, the NIST definition in SP800-145&lt;a href=&quot;http://csrc.nist.gov/publications/nistpubs/800-145/SP800-145.pdf&quot;&gt;1&lt;/a&gt;), self-service provisioning is a key tenet of cloud computing.&lt;/p&gt;

&lt;p&gt;However, fully automated IT management is a double-edged sword. While having people on the critical path for IT management was time-consuming, it provided an opportunity to ensure that those resources were managed sensibly and in a way that was consistent with how the business said they ought to be managed. In other words, having people on the critical path enabled IT resources to be managed according to &lt;em&gt;business policy&lt;/em&gt;. We cannot simply remove those people without also adding a way of ensuring that IT resources obey business policy—without introducing a way of ensuring that IT resources retain the same level of policy compliance.&lt;/p&gt;

&lt;p&gt;While many tools today (e.g. application lifecycle-management, templates, blueprints) claim they bring the data center into compliance with a given policy, there are often hidden assumptions underlying those claims. Before we can hope to understand how effective those tools are, we need to understand the problem of policy and policy compliance, which is the focus of this post. Future posts will begin laying out the space of policy compliance solutions and evaluating how existing policy efforts fit into that space.&lt;/p&gt;

&lt;h2 id=&quot;the-challenge-of-policy-compliance&quot;&gt;The Challenge of Policy Compliance&lt;/h2&gt;

&lt;p&gt;Policy compliance is challenging for several reasons. A business policy is often a combination of policies from many different sources. It’s something in the heads of IT operators (“This link is flakey, so route network traffic around it”). It’s written in English as organizational mandates (“We never put applications from different business units on the same production network”). It’s something expressed in contracts between organizations (“Our preferred partners are always given solid-state storage”). It’s something found in governmental legislation (“Data from Singapore’s citizens can never leave the geographic borders of Singapore”).&lt;/p&gt;

&lt;p&gt;To complicate matters, all of those different sources of policy have competing objectives, cross multiple levels of system abstraction, are often mutually inconsistent, and are constantly changing. Every time an individual policy changes, significant work may be required to understand the repercussions of those changes on the IT resources. Furthermore, not all policy is created equal. Sometimes it is permissible (or even inevitable) that some policies are violated temporarily (“Ensure every operating system always has the latest security patches installed”). The prospect of policy violations leads to the problem of making choices based on the differing penalties for those violations and how difficult they are to rectify. For example, a violation of the policy ensuring up-to-date operating systems is easy to remedy (install the latest patch), but a violation of a self-stated privacy policy for protecting customer information may cause a public relations storm, which is much harder to remedy.&lt;/p&gt;

&lt;p&gt;Despite its complexity, policy compliance is already being addressed today. People take high-level laws, rules, and regulations, and translate them into checklists that describe how the IT infrastructure must be architected, how the software applications running on that infrastructure must be written, and how software applications must be deployed on that infrastructure. Another group of people translate those checklists into configuration parameters for individual components of the infrastructure (e.g. servers, networks, storage) and into functional or non-functional software requirements for the applications deployed on that infrastructure. Network policy is implemented as a myriad of switch, router, and firewall configurations. Server policy is implemented by configuration management systems like Puppet/Chef/CFEngine, keeping systems up to date with the latest security patches, and ensuring that known vulnerabilities are mitigated with other mechanisms such as firewalls. Application developers write special-purpose code to address policy.&lt;/p&gt;

&lt;p&gt;Hopefully it is clear that policy compliance is a hard, hard problem. Some of the difficulties are unavoidable. People will always need to deal with the ambiguity and contradictions of laws, rules, and regulations. People will always need to translate those laws into the language of infrastructure and applications. People will always have the job of auditing to ensure a business is in compliance with the law.&lt;/p&gt;

&lt;h2 id=&quot;automating-policy-compliance&quot;&gt;Automating Policy Compliance&lt;/h2&gt;

&lt;p&gt;In this post, we focus on the aspects of the policy compliance problem that we believe are amenable to automation. We use the term &lt;em&gt;IT policy&lt;/em&gt; from this point forward to refer to the high-level laws, rules, and regulations &lt;em&gt;after&lt;/em&gt; they have been translated into the language of infrastructure and applications. This aspect of policy compliance is important because we believe we can automate much of it, and because there are numerous problems with how it is addressed today. For example:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;An IT policy is often written using fairly high-level concepts, e.g. the information applications manipulate, how applications are allowed to communicate, what their performance must be, and how they must be secured. The onus for translating these concepts into infrastructure configuration and application code is left to infrastructure operators and application developers. That translation process is error-prone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The results are often brittle. Moving a server or application from one network to another could cause a policy violation. A new application with different infrastructure requirements could force a network operator to remember why the configuration was the way it was, and to change it in a way that satisfies the IT policy for both the original and the new applications simultaneously.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When an auditor comes along to assess policy compliance, she must analyze the plethora of configurations, application code, architecture choices, and deployment options in the current system in order to understand what the IT policy that is being enforced actually is. Because this is so difficult, auditors typically use checklists that give an approximate understanding of compliance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Whenever the IT policy changes (e.g. because new legislation is passed), people must identify the infrastructure components and applications causing (what are suddenly) policy violations and rework them.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;key-components-of-policy-compliance-automation&quot;&gt;Key Components of Policy Compliance Automation&lt;/h2&gt;

&lt;p&gt;We believe that the same tools and technologies that helped automate IT management bring the promise of better, easier, and faster IT policy compliance through policy-aware systems. A policy-aware system has the potential to detect policy violations in the cloud and reconfigure automatically. A policy-aware system has the potential to identify situations where no matter what we do, there is no way to make a proposed change without violating policy. A policy-aware system has the potential to be told about policy updates and react accordingly. A policy-aware system has the potential to maintain enough state about the cloud to identify existing and potential policy violations and either prevent them from occurring or take corrective action.&lt;/p&gt;

&lt;p&gt;To enable policy-aware systems, we need at least two things.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We must communicate the IT policy to the system in a language it can understand. English won’t work; it is ambiguous and thus would require the computer to do the jobs of lawyers. Router and firewall configurations won’t work because they are too low level—the true intent of the policy is lost in the details. We need a language that can unambiguously describe both operational and infrastructure policies using concepts similar to those we would use if writing the policy in English.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We need a policy engine that understands that language, can act to bring IT resources into compliance, can interoperate with the ecosystem of software services in a cloud or across multiple clouds, and can help administrators and auditors understand where policy violations are and how to correct them.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In a future post, we’ll examine these key components in a bit more detail and discuss potential solutions for filling these roles. At that time, we’ll also discuss how recent developments like Group Policy for OpenDaylight and OpenStack Neutron fit into this landscape.&lt;/p&gt;

&lt;h2 id=&quot;one-more-thing-openness&quot;&gt;One More Thing: Openness&lt;/h2&gt;

&lt;p&gt;There is one more thing that is important for automated policy compliance: openness. As the “highest” layer in a fully-automated IT environment, policy represents the final layer of potential control or “lock-in.” As such, we believe it is critically important that an automated policy compliance solution not fall under the control of any one vendor. An automated policy compliance solution that offers cloud interoperability needs to be developed out in the open, with open governance, open collaboration, and open code access. By leveraging highly successful open source methodologies and approaches, this becomes possible.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-it-up&quot;&gt;Wrapping It Up&lt;/h2&gt;

&lt;p&gt;As we wrap this up and prepare for the next installation in this series, here are some key points to remember:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IT policy compliance in cloud environments is critical. IT resource management &lt;em&gt;cannot&lt;/em&gt; be fully and safely automated without policy compliance.&lt;/li&gt;
  &lt;li&gt;Manually enforcing IT policy isn’t sustainable in today’s fast-moving and highly fluid IT environments. An automated IT policy compliance solution is needed.&lt;/li&gt;
  &lt;li&gt;An automated IT policy compliance solution needs the right policy language—one that can express unambiguous concepts in a way that is consumable by both humans and software alike—as well as a policy engine that can understand this policy language and interact with an ecosystem of cloud services to enforce policy compliance.&lt;/li&gt;
  &lt;li&gt;Any policy compliance solution needs to be developed using an open source model, with open governance, open collaboration, and open code access.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next part of this series on automated policy compliance in cloud environments, we’ll take a deeper dive into looking at policy languages and policy engines that meet the needs described here.&lt;/p&gt;

</description>
                <pubDate>Wed, 16 Apr 2014 00:00:00 -0700</pubDate>
                <link>/2014/04/16/policy-problem.html</link>
                <guid isPermaLink="true">/2014/04/16/policy-problem.html</guid>
            </item>
        
    </channel>
</rss>
